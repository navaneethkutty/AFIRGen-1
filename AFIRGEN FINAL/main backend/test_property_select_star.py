"""
Property-Based Test for SELECT * Detection

This module contains property-based tests to verify that the system
never generates queries with SELECT * and always uses explicit column names.

Property 3: No SELECT * in generated queries
Validates: Requirements 1.4
"""

import pytest
from hypothesis import given, strategies as st, settings, assume
from infrastructure.query_optimizer import QueryOptimizer
from repositories.base_repository import BaseRepository, PaginatedResult
from repositories.fir_repository import FIRRepository, FIR
from typing import List, Optional, Dict, Any
from datetime import datetime
from unittest.mock import Mock, MagicMock


# Strategy for generating valid SQL identifiers
sql_identifier = st.text(
    min_size=1,
    max_size=30,
    alphabet=st.characters(
        whitelist_categories=('Lu', 'Ll'),
        min_codepoint=65,
        max_codepoint=122
    )
).filter(lambda x: x.isalpha() and x[0].isalpha())


# Strategy for generating column names
column_name = st.text(
    min_size=1,
    max_size=20,
    alphabet=st.characters(
        whitelist_categories=('Lu', 'Ll', 'Nd'),
        min_codepoint=48,
        max_codepoint=122
    )
).filter(lambda x: x and x[0].isalpha())


class TestSelectStarDetectionProperty:
    """
    Property-based tests for SELECT * detection.
    
    Validates that the system never generates queries with SELECT *
    and always uses explicit column names.
    """
    
    def setup_method(self):
        """Set up test fixtures."""
        self.optimizer = QueryOptimizer()
    
    @given(
        table_name=sql_identifier,
        column_names=st.lists(
            column_name,
            min_size=1,
            max_size=10,
            unique=True
        ),
        use_select_star=st.booleans()
    )
    @settings(max_examples=20)
    @pytest.mark.property_test
    def test_property_no_select_star_in_queries(
        self,
        table_name,
        column_names,
        use_select_star
    ):
        """
        Property 3: No SELECT * in generated queries.
        
        For any database query generated by the system, the SQL should
        explicitly specify column names rather than using SELECT *.
        
        **Validates: Requirements 1.4**
        """
        # Arrange: Generate a query with or without SELECT *
        if use_select_star:
            query = f"SELECT * FROM {table_name}"
        else:
            columns_str = ", ".join(column_names)
            query = f"SELECT {columns_str} FROM {table_name}"
        
        # Act: Check if query has SELECT *
        has_star = self.optimizer.has_select_star(query)
        
        # Assert: Verify correct detection
        if use_select_star:
            assert has_star is True, \
                f"Should detect SELECT * in query: {query}"
        else:
            assert has_star is False, \
                f"Should not detect SELECT * in query with explicit columns: {query}"
    
    @given(
        table_name=sql_identifier,
        column_names=st.lists(
            column_name,
            min_size=1,
            max_size=10,
            unique=True
        ),
        has_where=st.booleans(),
        has_order_by=st.booleans(),
        has_limit=st.booleans()
    )
    @settings(max_examples=20)
    @pytest.mark.property_test
    def test_property_select_star_detection_with_clauses(
        self,
        table_name,
        column_names,
        has_where,
        has_order_by,
        has_limit
    ):
        """
        Property 3 (Extended): SELECT * detection works with various SQL clauses.
        
        For any query with WHERE, ORDER BY, or LIMIT clauses, SELECT * should
        still be detected correctly.
        
        **Validates: Requirements 1.4**
        """
        # Arrange: Build query with explicit columns
        columns_str = ", ".join(column_names)
        query = f"SELECT {columns_str} FROM {table_name}"
        
        if has_where:
            query += " WHERE id = 1"
        
        if has_order_by:
            query += f" ORDER BY {column_names[0]} DESC"
        
        if has_limit:
            query += " LIMIT 10"
        
        # Act: Check for SELECT *
        has_star = self.optimizer.has_select_star(query)
        
        # Assert: Should not detect SELECT * with explicit columns
        assert has_star is False, \
            f"Should not detect SELECT * in query with explicit columns: {query}"
        
        # Now test with SELECT *
        query_with_star = f"SELECT * FROM {table_name}"
        
        if has_where:
            query_with_star += " WHERE id = 1"
        
        if has_order_by:
            query_with_star += f" ORDER BY {column_names[0]} DESC"
        
        if has_limit:
            query_with_star += " LIMIT 10"
        
        has_star_in_star_query = self.optimizer.has_select_star(query_with_star)
        
        assert has_star_in_star_query is True, \
            f"Should detect SELECT * even with additional clauses: {query_with_star}"
    
    @given(
        table_name=sql_identifier,
        column_names=st.lists(
            column_name,
            min_size=1,
            max_size=5,
            unique=True
        ),
        case_variant=st.sampled_from(['upper', 'lower', 'mixed', 'title'])
    )
    @settings(max_examples=20)
    @pytest.mark.property_test
    def test_property_select_star_case_insensitive(
        self,
        table_name,
        column_names,
        case_variant
    ):
        """
        Property 3 (Case Insensitivity): SELECT * detection is case-insensitive.
        
        For any query with SELECT * in any case combination, it should be detected.
        
        **Validates: Requirements 1.4**
        """
        # Arrange: Create query with different case variants
        if case_variant == 'upper':
            query = f"SELECT * FROM {table_name}"
        elif case_variant == 'lower':
            query = f"select * from {table_name}"
        elif case_variant == 'mixed':
            query = f"SeLeCt * FrOm {table_name}"
        else:  # title
            query = f"Select * From {table_name}"
        
        # Act: Check for SELECT *
        has_star = self.optimizer.has_select_star(query)
        
        # Assert: Should detect SELECT * regardless of case
        assert has_star is True, \
            f"Should detect SELECT * case-insensitively in: {query}"
        
        # Test with explicit columns
        columns_str = ", ".join(column_names)
        if case_variant == 'upper':
            query_explicit = f"SELECT {columns_str} FROM {table_name}"
        elif case_variant == 'lower':
            query_explicit = f"select {columns_str} from {table_name}"
        elif case_variant == 'mixed':
            query_explicit = f"SeLeCt {columns_str} FrOm {table_name}"
        else:
            query_explicit = f"Select {columns_str} From {table_name}"
        
        has_star_explicit = self.optimizer.has_select_star(query_explicit)
        
        assert has_star_explicit is False, \
            f"Should not detect SELECT * with explicit columns: {query_explicit}"
    
    @given(
        table_name=sql_identifier,
        whitespace_count=st.integers(min_value=1, max_value=10)
    )
    @settings(max_examples=20)
    @pytest.mark.property_test
    def test_property_select_star_with_whitespace(
        self,
        table_name,
        whitespace_count
    ):
        """
        Property 3 (Whitespace Handling): SELECT * detection handles extra whitespace.
        
        For any query with SELECT * and varying amounts of whitespace,
        it should be detected correctly.
        
        **Validates: Requirements 1.4**
        """
        # Arrange: Create query with extra whitespace
        spaces = " " * whitespace_count
        query = f"SELECT{spaces}*{spaces}FROM{spaces}{table_name}"
        
        # Act: Check for SELECT *
        has_star = self.optimizer.has_select_star(query)
        
        # Assert: Should detect SELECT * with extra whitespace
        assert has_star is True, \
            f"Should detect SELECT * with extra whitespace: {query}"
    
    @given(
        table_name=sql_identifier,
        aggregate_func=st.sampled_from(['COUNT', 'MAX', 'MIN', 'SUM', 'AVG'])
    )
    @settings(max_examples=20)
    @pytest.mark.property_test
    def test_property_aggregate_functions_not_flagged(
        self,
        table_name,
        aggregate_func
    ):
        """
        Property 3 (Aggregate Functions): Aggregate functions with * are not flagged.
        
        For any query using aggregate functions like COUNT(*), it should NOT
        be flagged as SELECT *.
        
        **Validates: Requirements 1.4**
        """
        # Arrange: Create query with aggregate function
        query = f"SELECT {aggregate_func}(*) FROM {table_name}"
        
        # Act: Check for SELECT *
        has_star = self.optimizer.has_select_star(query)
        
        # Assert: Should NOT detect SELECT * for aggregate functions
        assert has_star is False, \
            f"Should not flag {aggregate_func}(*) as SELECT *: {query}"
        
        # Test with additional columns
        query_with_cols = f"SELECT {aggregate_func}(*), id FROM {table_name}"
        has_star_with_cols = self.optimizer.has_select_star(query_with_cols)
        
        assert has_star_with_cols is False, \
            f"Should not flag {aggregate_func}(*) with other columns: {query_with_cols}"
    
    @given(
        table1=sql_identifier,
        table2=sql_identifier,
        column_names=st.lists(
            column_name,
            min_size=1,
            max_size=5,
            unique=True
        ),
        use_select_star=st.booleans()
    )
    @settings(max_examples=20)
    @pytest.mark.property_test
    def test_property_select_star_in_joins(
        self,
        table1,
        table2,
        column_names,
        use_select_star
    ):
        """
        Property 3 (JOIN Queries): SELECT * detection works in JOIN queries.
        
        For any query with JOINs, SELECT * should be detected correctly.
        
        **Validates: Requirements 1.4**
        """
        # Assume tables are different
        assume(table1 != table2)
        
        # Arrange: Create JOIN query
        if use_select_star:
            query = f"SELECT * FROM {table1} t1 JOIN {table2} t2 ON t1.id = t2.id"
        else:
            columns_str = ", ".join([f"t1.{col}" for col in column_names])
            query = f"SELECT {columns_str} FROM {table1} t1 JOIN {table2} t2 ON t1.id = t2.id"
        
        # Act: Check for SELECT *
        has_star = self.optimizer.has_select_star(query)
        
        # Assert: Verify correct detection
        if use_select_star:
            assert has_star is True, \
                f"Should detect SELECT * in JOIN query: {query}"
        else:
            assert has_star is False, \
                f"Should not detect SELECT * in JOIN with explicit columns: {query}"


class TestRepositorySelectStarProperty:
    """
    Property-based tests verifying that repository methods never generate SELECT *.
    
    Tests the actual repository implementation to ensure it follows the
    "no SELECT *" requirement.
    """
    
    def setup_method(self):
        """Set up test fixtures."""
        self.optimizer = QueryOptimizer()
        # Create mock connection
        self.mock_connection = Mock()
        self.mock_cursor = MagicMock()
        self.mock_connection.cursor.return_value = self.mock_cursor
        self.mock_cursor.__enter__ = Mock(return_value=self.mock_cursor)
        self.mock_cursor.__exit__ = Mock(return_value=False)
    
    @given(
        fields=st.one_of(
            st.none(),
            st.lists(
                st.sampled_from(FIRRepository.ALL_COLUMNS),
                min_size=1,
                max_size=len(FIRRepository.ALL_COLUMNS),
                unique=True
            )
        )
    )
    @settings(max_examples=20)
    @pytest.mark.property_test
    def test_property_repository_build_column_list_no_select_star(self, fields):
        """
        Property 3 (Repository): Repository never generates SELECT *.
        
        For any field list (including None), the repository should generate
        explicit column names, never SELECT *.
        
        **Validates: Requirements 1.4**
        """
        # Arrange: Create repository
        repo = FIRRepository(self.mock_connection)
        
        # Act: Build column list
        column_list = repo._build_column_list(fields)
        
        # Assert: Should never be just "*"
        # If fields is None, should return all columns explicitly
        # If fields is provided, should return those columns
        
        if fields is None:
            # Should return all columns explicitly
            assert column_list == ", ".join(FIRRepository.ALL_COLUMNS), \
                f"Repository should return explicit columns, not *: {column_list}"
        else:
            # Should return requested fields
            expected = ", ".join(fields)
            assert column_list == expected, \
                f"Repository should return requested fields: expected {expected}, got {column_list}"
        
        # Verify no SELECT * pattern
        assert column_list != "*", \
            "Repository should never return just '*'"
        
        # Verify it's a comma-separated list of identifiers
        columns = [c.strip() for c in column_list.split(',')]
        assert len(columns) > 0, \
            "Column list should contain at least one column"
        
        for col in columns:
            assert col != "*", \
                f"Column list should not contain '*': {column_list}"
            assert len(col) > 0, \
                f"Column list should not contain empty strings: {column_list}"
    
    @given(
        entity_id=st.text(min_size=1, max_size=50),
        fields=st.one_of(
            st.none(),
            st.lists(
                st.sampled_from(FIRRepository.ALL_COLUMNS),
                min_size=1,
                max_size=5,
                unique=True
            )
        )
    )
    @settings(max_examples=20)
    @pytest.mark.property_test
    def test_property_find_by_id_no_select_star(self, entity_id, fields):
        """
        Property 3 (find_by_id): find_by_id never generates SELECT *.
        
        For any entity ID and field list, the generated query should use
        explicit column names.
        
        **Validates: Requirements 1.4**
        """
        # Arrange: Create repository and mock cursor
        repo = FIRRepository(self.mock_connection)
        self.mock_cursor.fetchone.return_value = None
        
        # Capture the executed query
        executed_queries = []
        
        def capture_execute(query, params=None):
            executed_queries.append(query)
        
        self.mock_cursor.execute = capture_execute
        
        # Act: Call find_by_id
        try:
            repo.find_by_id(entity_id, fields)
        except Exception:
            # Ignore exceptions from mock, we just want to capture the query
            pass
        
        # Assert: Verify no SELECT * in generated query
        assert len(executed_queries) > 0, \
            "Should have executed at least one query"
        
        query = executed_queries[0]
        has_star = self.optimizer.has_select_star(query)
        
        assert has_star is False, \
            f"find_by_id should not generate SELECT *: {query}"
        
        # Verify explicit columns are in the query
        if fields:
            for field in fields:
                assert field in query, \
                    f"Requested field '{field}' should be in query: {query}"
        else:
            # Should contain all columns
            for col in FIRRepository.ALL_COLUMNS:
                assert col in query, \
                    f"Column '{col}' should be in query: {query}"
    
    @given(
        user_id=st.text(min_size=1, max_size=50),
        fields=st.one_of(
            st.none(),
            st.lists(
                st.sampled_from(FIRRepository.ALL_COLUMNS),
                min_size=1,
                max_size=5,
                unique=True
            )
        ),
        limit=st.integers(min_value=1, max_value=100)
    )
    @settings(max_examples=20)
    @pytest.mark.property_test
    def test_property_find_by_user_no_select_star(self, user_id, fields, limit):
        """
        Property 3 (find_by_user): find_by_user never generates SELECT *.
        
        For any user ID, field list, and limit, the generated query should use
        explicit column names.
        
        **Validates: Requirements 1.4**
        """
        # Arrange: Create repository and mock cursor
        repo = FIRRepository(self.mock_connection)
        self.mock_cursor.fetchall.return_value = []
        
        # Capture the executed query
        executed_queries = []
        
        def capture_execute(query, params=None):
            executed_queries.append(query)
        
        self.mock_cursor.execute = capture_execute
        
        # Act: Call find_by_user
        try:
            repo.find_by_user(user_id, fields, limit)
        except Exception:
            # Ignore exceptions from mock
            pass
        
        # Assert: Verify no SELECT * in generated query
        assert len(executed_queries) > 0, \
            "Should have executed at least one query"
        
        query = executed_queries[0]
        has_star = self.optimizer.has_select_star(query)
        
        assert has_star is False, \
            f"find_by_user should not generate SELECT *: {query}"
        
        # Verify the query contains explicit columns
        if fields:
            for field in fields:
                assert field in query, \
                    f"Requested field '{field}' should be in query: {query}"


class TestSystemWideSelectStarProperty:
    """
    System-wide property tests to ensure no SELECT * in any generated queries.
    
    This test class validates that across all repository methods and query
    generation patterns, SELECT * is never used.
    """
    
    def setup_method(self):
        """Set up test fixtures."""
        self.optimizer = QueryOptimizer()
    
    @given(
        query_pattern=st.sampled_from([
            "SELECT {cols} FROM table_name",
            "SELECT {cols} FROM table_name WHERE id = 1",
            "SELECT {cols} FROM table_name ORDER BY created_at",
            "SELECT {cols} FROM table_name LIMIT 10",
            "SELECT {cols} FROM t1 JOIN t2 ON t1.id = t2.id",
            "SELECT {cols} FROM table_name WHERE status = 'active' ORDER BY id LIMIT 5"
        ]),
        column_names=st.lists(
            column_name,
            min_size=1,
            max_size=8,
            unique=True
        )
    )
    @settings(max_examples=20)
    @pytest.mark.property_test
    def test_property_system_generated_queries_explicit_columns(
        self,
        query_pattern,
        column_names
    ):
        """
        Property 3 (System-Wide): All system-generated queries use explicit columns.
        
        For any query pattern used in the system, when columns are specified,
        they should be explicit, never SELECT *.
        
        **Validates: Requirements 1.4**
        """
        # Arrange: Generate query with explicit columns
        columns_str = ", ".join(column_names)
        query = query_pattern.format(cols=columns_str)
        
        # Act: Check for SELECT *
        has_star = self.optimizer.has_select_star(query)
        
        # Assert: Should not have SELECT *
        assert has_star is False, \
            f"System-generated query should not use SELECT *: {query}"
        
        # Verify all columns are present
        for col in column_names:
            assert col in query, \
                f"Column '{col}' should be in query: {query}"
        
        # Test that SELECT * would be detected in the same pattern
        query_with_star = query_pattern.format(cols="*")
        has_star_in_star_query = self.optimizer.has_select_star(query_with_star)
        
        assert has_star_in_star_query is True, \
            f"SELECT * should be detected in pattern: {query_with_star}"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-m", "property_test"])
